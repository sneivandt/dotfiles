#!/bin/sh
#
# Pre-commit hook that scans for sensitive information like credentials,
# API keys, private keys, secrets, PII, and other data that should not be committed.
#
# This hook is specific to the dotfiles repository and is installed
# by the dotfiles installation script.
#
# To bypass this hook temporarily, use: git commit --no-verify

set -o errexit
set -o nounset

# Color codes for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Get the directory where this hook's actual file is located (follow symlink)
# The hook is symlinked from .git/hooks/pre-commit to hooks/pre-commit
if [ -L "$0" ]; then
  # Follow the symlink to get the real file location
  HOOK_FILE=$(readlink "$0")
  # If relative path, make it absolute from $0's directory
  case "$HOOK_FILE" in
    /*) ;; # Already absolute
    *) HOOK_FILE="$(cd "$(dirname "$0")" && cd "$(dirname "$HOOK_FILE")" && pwd)/$(basename "$HOOK_FILE")" ;;
  esac
else
  HOOK_FILE="$0"
fi

PATTERNS_FILE="$(dirname "$HOOK_FILE")/sensitive-patterns.ini"

# Check if patterns file exists
if [ ! -f "$PATTERNS_FILE" ]; then
  printf "${RED}ERROR: Patterns file not found: %s${NC}\n" "$PATTERNS_FILE"
  printf "${YELLOW}Cannot perform credential scanning without patterns file.${NC}\n"
  exit 1
fi

# Read patterns from file
PATTERNS=$(cat "$PATTERNS_FILE")

# Get list of staged files
if git rev-parse --verify HEAD >/dev/null 2>&1; then
  against=HEAD
else
  # Initial commit: diff against an empty tree object
  against=$(git hash-object -t tree /dev/null)
fi

# Track if any secrets were found
found_secrets=0

# Check each staged file
for file in $(git diff --cached --name-only --diff-filter=ACM "$against"); do
  # Skip deleted files
  if [ ! -f "$file" ]; then
    continue
  fi

  # Get the diff for this file (only added lines)
  diff=$(git diff --cached --unified=0 "$against" -- "$file" | grep '^+' | grep -v '^+++' || true)

  if [ -z "$diff" ]; then
    continue
  fi

  # Check each pattern
  while IFS= read -r pattern; do
    # Skip empty lines, comments, and section headers
    case "$pattern" in
      ''|'#'*|'['*']') continue ;;
    esac

    # Case-insensitive grep for the pattern
    # Use -- to prevent patterns starting with - from being interpreted as options
    if echo "$diff" | grep -qiE -- "$pattern"; then
      if [ "$found_secrets" -eq 0 ]; then
        printf "${RED}ERROR: Potential sensitive information detected!${NC}\n"
        printf "${RED}======================================================${NC}\n\n"
        found_secrets=1
      fi

      printf "${YELLOW}In file: %s${NC}\n" "$file"
      printf "${YELLOW}Pattern matched: %s${NC}\n\n" "$pattern"
    fi
  done <<PATTERNS_EOF
$PATTERNS
PATTERNS_EOF
done

# If secrets were found, prevent the commit
if [ "$found_secrets" -eq 1 ]; then
  printf "${RED}======================================================${NC}\n"
  printf "${RED}Commit aborted to prevent leaking sensitive data.${NC}\n"
  printf "${YELLOW}Please review and remove any sensitive information.${NC}\n"
  printf "${YELLOW}If this is a false positive, use:${NC}\n"
  printf "  git commit --no-verify\n\n"
  exit 1
fi

exit 0
